"use strict";exports.id=925,exports.ids=[925],exports.modules={43895:(e,r,t)=>{t.d(r,{k:()=>d});var n=t(94624),i=t.n(n),s=t(92048),o=t(55315);let a=process.env.LOG_FILE||(0,o.join)(process.cwd(),"data","bot.log"),c=process.env.LOG_LEVEL||"info",l=(0,o.dirname)(a);(0,s.existsSync)(l)||(0,s.mkdirSync)(l,{recursive:!0});let d=i().createLogger({level:c,format:i().format.combine(i().format.timestamp({format:"YYYY-MM-DD HH:mm:ss.SSS"}),i().format.printf(({timestamp:e,level:r,message:t,...n})=>{let i=Object.keys(n).length?` ${JSON.stringify(n)}`:"";return`[${e}] ${r.toUpperCase()}: ${t}${i}`})),transports:[new(i()).transports.Console({format:i().format.combine(i().format.colorize(),i().format.timestamp({format:"HH:mm:ss"}),i().format.printf(({timestamp:e,level:r,message:t})=>`[${e}] ${r}: ${t}`))}),new(i()).transports.File({filename:a,maxsize:10485760,maxFiles:5})]})},21925:(e,r,t)=>{t.a(e,async(e,n)=>{try{t.d(r,{A_:()=>g,EG:()=>E,L4:()=>m,SX:()=>k,YX:()=>S,checkProxyTokenBalance:()=>y,eE:()=>A,fA:()=>L,sl:()=>w,tS:()=>p});var i=t(67332),s=t(47152),o=t(90399),a=t(12792),c=t(99648),l=t(35240),d=t.n(l),u=t(43895),f=e([i,c]);[i,c]=f.then?(await f)():f;let v=new(d()).Agent({ciphers:"TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-SHA:ECDHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA:AES256-SHA",minVersion:"TLSv1.2",maxVersion:"TLSv1.3",keepAlive:!0});c.default.interceptors.request.use(e=>(e.headers["User-Agent"]="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",e.headers.Accept="application/json, text/plain, */*",e.headers["Accept-Language"]="en-US,en;q=0.9",e.headers.Connection="keep-alive",e.httpAgent=e.httpAgent||v,e.httpsAgent=e.httpsAgent||v,e.timeout=e.timeout||5e3,e));let h=null,I=null,P=process.env.POLYGON_RPC_URL||"https://polygon-rpc.com";async function p(){if(h)return h;let e=process.env.PRIVATE_KEY,r=process.env.FUNDER_ADDRESS,t=process.env.CLOB_API_URL||"https://clob.polymarket.com",n=parseInt(process.env.CHAIN_ID||"137"),a=parseInt(process.env.SIGNATURE_TYPE||"2");if(!e||!r)return u.k.warn("No PRIVATE_KEY or FUNDER_ADDRESS set — live trading unavailable"),null;try{let c=new o.StaticJsonRpcProvider(P,137),l=new s.Wallet(e,c),d=process.env.CLOB_API_KEY,f=process.env.CLOB_SECRET,p=process.env.CLOB_PASSPHRASE;if(d&&f&&p)I={key:d,secret:f,passphrase:p},u.k.info("Using pre-configured CLOB API keys from .env");else{let e=new i.ClobClient(t,n,l,void 0,a,r);I=await e.createOrDeriveApiKey(),u.k.info("API keys derived from Polymarket")}return h=new i.ClobClient(t,n,l,I,a,r),u.k.info("CLOB client initialized successfully"),h}catch(e){return u.k.error(`Failed to initialize CLOB client: ${e}`),null}}function S(){let e=process.env.CLOB_API_URL||"https://clob.polymarket.com",r=parseInt(process.env.CHAIN_ID||"137");return new i.ClobClient(e,r)}async function m(e,r,t,n,s){let o=await p();if(!o)return{success:!1,error:"CLOB client not initialized"};try{let a=Math.floor(100*t)/100;if(a<=0)return{success:!1,error:`Size too small after rounding: ${t}`};let c=parseFloat(n)||.01,l=Math.min(.99,Math.round((r+.03)/c)*c);u.k.info(`[LIVE] BUY: ${a.toFixed(2)} shares @ $${l.toFixed(4)} (mid=$${r.toFixed(4)}) | token=${e.slice(0,10)}...`);let d=await o.createAndPostOrder({tokenID:e,price:l,side:i.Side.BUY,size:a,feeRateBps:void 0,nonce:void 0,expiration:void 0},{tickSize:n,negRisk:s});u.k.info(`[LIVE] BUY response: ${JSON.stringify(d)}`);let f=d?.orderID||d?.orderIds?.[0];if(!f||"unknown"===f){if(d?.error){let e="string"==typeof d.error?d.error:JSON.stringify(d.error);return u.k.error(`[LIVE] BUY rejected by API: ${e} (status: ${d.status||"unknown"})`),{success:!1,error:`API rejected: ${e}`}}return u.k.error(`Buy order returned no orderId: ${JSON.stringify(d)}`),{success:!1,error:"No orderId returned from Polymarket"}}let S=await $(f,4e3,400);if(!S.filled||S.sizeFilled<=0){u.k.warn(`Buy order ${f} NOT filled (status: ${S.status}) — cancelling`);try{let e=await p();e&&await e.cancelOrder({orderID:f}),u.k.info(`[LIVE] Cancelled unfilled buy order ${f}`)}catch(e){u.k.warn(`[LIVE] Failed to cancel unfilled buy order ${f}: ${e}`)}return{success:!1,error:`Order not filled (status: ${S.status})`,orderId:f}}return u.k.info(`Buy FILLED: ${S.sizeFilled.toFixed(4)} shares @ $${S.avgPrice.toFixed(4)} | token=${e.slice(0,10)}...`),{success:!0,orderId:f,filledSize:S.sizeFilled,filledPrice:S.avgPrice||l}}catch(r){let e=r instanceof Error?r.message:String(r);return u.k.error(`Buy order failed: ${e}`),{success:!1,error:e}}}async function E(e,r,t,n,s){let o=await p();if(!o)return{success:!1,error:"CLOB client not initialized"};try{let a=Math.floor(100*t)/100;if(a<=0)return{success:!1,error:`Size too small after rounding: ${t}`};let c=parseFloat(n)||.01,l=Math.max(.01,Math.round((r-.03)/c)*c);u.k.info(`[LIVE] SELL: ${a.toFixed(2)} shares @ $${l.toFixed(4)} (mid=$${r.toFixed(4)}) | token=${e.slice(0,10)}...`);let d=await o.createAndPostOrder({tokenID:e,price:l,side:i.Side.SELL,size:a,feeRateBps:void 0,nonce:void 0,expiration:void 0},{tickSize:n,negRisk:s});u.k.info(`[LIVE] SELL response: ${JSON.stringify(d)}`);let f=d?.orderID||d?.orderIds?.[0];if(!f||"unknown"===f){if(d?.error){let e="string"==typeof d.error?d.error:JSON.stringify(d.error);return u.k.error(`[LIVE] SELL rejected by API: ${e} (status: ${d.status||"unknown"})`),{success:!1,error:`API rejected: ${e}`}}return u.k.error(`Sell order returned no orderId: ${JSON.stringify(d)}`),{success:!1,error:"No orderId returned from Polymarket"}}let S=await $(f,4e3,400);if(!S.filled||S.sizeFilled<=0){u.k.warn(`Sell order ${f} NOT filled (status: ${S.status}) — cancelling`);try{let e=await p();e&&await e.cancelOrder({orderID:f}),u.k.info(`[LIVE] Cancelled unfilled sell order ${f}`)}catch(e){u.k.warn(`[LIVE] Failed to cancel unfilled sell order ${f}: ${e}`)}return{success:!1,error:`Order not filled (status: ${S.status})`,orderId:f}}return u.k.info(`Sell FILLED: ${S.sizeFilled.toFixed(4)} shares @ $${S.avgPrice.toFixed(4)} | token=${e.slice(0,10)}...`),{success:!0,orderId:f,filledSize:S.sizeFilled,filledPrice:S.avgPrice||l}}catch(r){let e=r instanceof Error?r.message:String(r);return u.k.error(`Sell order failed: ${e}`),{success:!1,error:e}}}async function A(e,r,t,n,s){let o=await p();if(!o)return{success:!1,error:"CLOB client not initialized"};try{let a=Math.floor(100*t)/100;if(a<=0)return{success:!1,error:`Size too small after rounding: ${t}`};let c=await o.createAndPostOrder({tokenID:e,price:r,side:i.Side.SELL,size:a,feeRateBps:void 0,nonce:void 0,expiration:void 0},{tickSize:n,negRisk:s},i.OrderType.GTC),l=c?.orderID||c?.orderIds?.[0];if(!l){if(c?.error){let e="string"==typeof c.error?c.error:JSON.stringify(c.error);return u.k.error(`[SCALP] Limit sell rejected: ${e}`),{success:!1,error:`API rejected: ${e}`}}return{success:!1,error:"No orderId returned"}}return u.k.info(`[SCALP] Limit sell placed: ${a.toFixed(2)} shares @ $${r} | token=${e.slice(0,10)}...`),{success:!0,orderId:l}}catch(r){let e=r instanceof Error?r.message:String(r);return u.k.error(`[SCALP] Limit sell failed: ${e}`),{success:!1,error:e}}}async function w(e){let r=await p();if(!r)return{success:!1,error:"CLOB client not initialized"};try{return await r.cancelOrder({orderID:e}),u.k.info(`[ARB] Order cancelled: ${e}`),{success:!0}}catch(t){let r=t instanceof Error?t.message:String(t);return u.k.error(`[ARB] Cancel failed for ${e}: ${r}`),{success:!1,error:r}}}async function k(e){let r=await p();if(!r)return null;try{let t=await r.getOrder(e);if(!t)return null;let n=parseFloat(t.size_matched||"0");parseFloat(t.original_size||"0");let i=parseFloat(t.price||"0"),s=t.status||"unknown";return{filled:n>0,sizeFilled:n,sizeMatched:n,status:s,price:i}}catch(r){return u.k.error(`Failed to get order status for ${e}: ${r}`),null}}async function $(e,r=5e3,t=500){let n=Date.now(),i=null;for(;Date.now()-n<r;){if(!(i=await k(e))){await new Promise(e=>setTimeout(e,t));continue}let r=i.status.toUpperCase();if("MATCHED"===r||"CLOSED"===r||"FILLED"===r)return{filled:i.sizeFilled>0,sizeFilled:i.sizeFilled,avgPrice:i.price,status:i.status};if("CANCELLED"===r||"EXPIRED"===r||"REJECTED"===r)return{filled:!1,sizeFilled:0,avgPrice:0,status:i.status};i.sizeFilled,await new Promise(e=>setTimeout(e,t))}return i&&i.sizeFilled>0?(u.k.info(`[FILL] Timeout but partial fill found: ${i.sizeFilled} shares @ $${i.price}`),{filled:!0,sizeFilled:i.sizeFilled,avgPrice:i.price,status:i.status}):{filled:!1,sizeFilled:0,avgPrice:0,status:i?.status||"timeout"}}let R="0x4D97DCd97eC945f40cF65F87097ACe5EA0476045",D="0xd91E80cF2E7be2e162c6513ceD06f1dD0dA35296",O="0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",F=["function redeemPositions(address collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] indexSets)","function balanceOf(address owner, uint256 id) view returns (uint256)","function getCollectionId(bytes32 parentCollectionId, bytes32 conditionId, uint256 indexSet) view returns (bytes32)","function getPositionId(address collateralToken, bytes32 collectionId) view returns (uint256)","function payoutDenominator(bytes32 conditionId) view returns (uint256)"],b=["function redeemPositions(bytes32 conditionId, uint256[] indexSets)","function balanceOf(address owner, uint256 id) view returns (uint256)","function getDetermined(bytes32 questionId) view returns (bool)","function payoutNumerators(bytes32 questionId, uint256 index) view returns (uint256)"],_=["function execTransaction(address to, uint256 value, bytes data, uint8 operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, bytes signatures) payable returns (bool)","function getTransactionHash(address to, uint256 value, bytes data, uint8 operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, uint256 _nonce) view returns (bytes32)","function nonce() view returns (uint256)"];async function y(e){let r=process.env.FUNDER_ADDRESS;if(!r)return!1;try{let t=process.env.POLYGON_RPC_URL||"https://polygon-rpc.com",n=new o.StaticJsonRpcProvider(t,137),i=new a.Contract(R,F,n);for(let t of[1,2])try{let n=await i.getCollectionId("0x0000000000000000000000000000000000000000000000000000000000000000",e,t),s=await i.getPositionId(O,n),o=await i.balanceOf(r,s);if(Number(o)>0)return u.k.info(`[Redeem] Proxy has ${o.toString()} tokens for ${e.slice(0,10)}... (idx=${t})`),!0}catch{}return!1}catch(r){return u.k.warn(`[Redeem] Balance check failed for ${e.slice(0,10)}...: ${r}`),!1}}async function C(e,r){try{let t=process.env.POLYGON_RPC_URL||"https://polygon-rpc.com",n=new o.StaticJsonRpcProvider(t,137);if(r){let r=new a.Contract(D,b,n);if(await r.getDetermined(e))return!0;let t=new a.Contract(R,F,n),i=await t.payoutDenominator(e);return Number(i)>0}let i=new a.Contract(R,F,n),s=await i.payoutDenominator(e);return Number(s)>0}catch{return!1}}async function g(){let e=await p(),r=process.env.FUNDER_ADDRESS;if(!e||!r)return u.k.warn("[Redeem] No CLOB client or FUNDER_ADDRESS"),[];try{u.k.info("[Redeem] Fetching trades from CLOB API...");let t=await e.getTrades(void 0,!1);if(!t||0===t.length)return u.k.info("[Redeem] CLOB API returned 0 trades"),[];let n=process.env.POLYGON_RPC_URL||"https://polygon-rpc.com",i=new o.StaticJsonRpcProvider(n,137),s=new a.Contract(R,F,i),c=new a.Contract(D,b,i),l=new Map;for(let e of t)e.market&&e.asset_id&&(l.has(e.market)||l.set(e.market,new Set),l.get(e.market).add(e.asset_id));u.k.info(`[Redeem] ${t.length} trades across ${l.size} markets, checking balances for ${r}`);let d=[],f=new Set;for(let[e,t]of l)if(!f.has(e))for(let n of t)try{let t=await s.balanceOf(r,n).catch(()=>0),i=await c.balanceOf(r,n).catch(()=>0),o=Number(t),a=Number(i);if(o>0||a>0){let r=a>0;u.k.info(`[Redeem] HAS TOKENS: conditionId=${e.slice(0,10)}... token=${n.slice(0,10)}... ctf=${o} negRisk=${a}`),f.add(e),d.push({conditionId:e,negRisk:r});break}}catch(e){u.k.debug(`[Redeem] balanceOf error for ${n.slice(0,10)}...: ${e}`)}return u.k.info(`[Redeem] Found ${d.length} claimable position(s)`),d}catch(e){return u.k.error(`[Redeem] Scan failed: ${e}`),[]}}async function L(e,r){let n=process.env.PRIVATE_KEY,i=process.env.FUNDER_ADDRESS;if(!n||!i)return{success:!1,error:"No PRIVATE_KEY or FUNDER_ADDRESS"};try{let c,l;let d=process.env.POLYGON_RPC_URL||"https://polygon-rpc.com",f=new o.StaticJsonRpcProvider(d,137),p=new s.Wallet(n,f),{Interface:S}=await Promise.all([t.e(805),t.e(267)]).then(t.bind(t,63267)),{arrayify:m,hexlify:E}=await t.e(805).then(t.bind(t,91805)),A="0x0000000000000000000000000000000000000000",w=[1,2];if(!await C(e,r))return u.k.info(`[Redeem] Condition ${e.slice(0,10)}... not yet resolved on-chain`),{success:!1,error:"Condition not yet resolved on-chain"};if(!await y(e))return u.k.info(`[Redeem] No tokens at proxy wallet for ${e.slice(0,10)}...`),{success:!0};r?(l=new S(b).encodeFunctionData("redeemPositions",[e,w]),c=D):(l=new S(F).encodeFunctionData("redeemPositions",[O,"0x0000000000000000000000000000000000000000000000000000000000000000",e,w]),c=R);let k=new a.Contract(i,_,p),$=await k.nonce(),g=await k.getTransactionHash(c,0,l,0,0,0,0,A,A,$),L=await p.signMessage(m(g)),v=m(L);v[64]+=4;let h=E(v),I=await k.execTransaction(c,0,l,0,0,0,0,A,A,h,{gasLimit:5e5}),P=await I.wait();if(0===P.status)return u.k.error(`[Redeem] Safe tx reverted: ${I.hash} | conditionId=${e.slice(0,10)}...`),{success:!1,error:"Safe transaction reverted on-chain"};return u.k.info(`[Redeem] Claimed via Safe tx: ${I.hash} | conditionId=${e.slice(0,10)}...`),{success:!0}}catch(t){let r=t instanceof Error?t.message:String(t);return u.k.error(`[Redeem] Failed for ${e.slice(0,10)}...: ${r}`),{success:!1,error:r}}}n()}catch(e){n(e)}})}};