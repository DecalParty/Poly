"use strict";exports.id=129,exports.ids=[129],exports.modules={81129:(e,t,n)=>{n.d(t,{y0:()=>e$,ap:()=>et,xS:()=>eP,zX:()=>ey,hC:()=>eS,BU:()=>el});var r=n(35240),i=n.n(r),a=n(72019),s=n(21925),o=n(43895);async function l(e,t,n=3){for(let r=0;r<n;r++)try{return await function(e,t){let n=new URLSearchParams(t).toString(),r=`${e}?${n}`;return new Promise((e,t)=>{let n=i().get({hostname:"gamma-api.polymarket.com",path:r,headers:{"User-Agent":"Mozilla/5.0",Accept:"application/json"},timeout:1e4},n=>{if(n.statusCode&&n.statusCode>=400){let e=Error(`${n.statusCode} ${n.statusMessage}`);e.status=n.statusCode,n.resume(),t(e);return}let r="";n.on("data",e=>r+=e),n.on("end",()=>{try{e(JSON.parse(r))}catch(e){t(e)}})});n.on("error",t),n.on("timeout",()=>{n.destroy(),t(Error("timeout"))})})}(e,t)}catch(s){if(r===n-1)throw s;let i=s.status;if(i&&i>=400&&i<500&&429!==i)throw s;let a=Math.min(1e3*Math.pow(2,r),8e3);o.k.warn(`[Markets] ${e}?${new URLSearchParams(t)} failed (attempt ${r+1}/${n}), retrying in ${a}ms`),await new Promise(e=>setTimeout(e,a))}throw Error("Unreachable")}async function d(e){try{let t=await l("/markets",{slug:e});if(!t||!Array.isArray(t)||0===t.length)return o.k.debug(`No market found for slug: ${e}`),null;let n=t[0],r=n.clobTokenIds?"string"==typeof n.clobTokenIds?JSON.parse(n.clobTokenIds):n.clobTokenIds:[];if(r.length<2)return o.k.warn(`Market ${e} has insufficient token IDs`),null;return{conditionId:n.conditionId,slug:n.slug||e,question:n.question||"BTC 15m candle",yesTokenId:r[0],noTokenId:r[1],endDate:n.endDate||n.endDateIso||"",endTimestamp:n.endDate?new Date(n.endDate).getTime()/1e3:0,active:!1!==n.active&&!n.closed,tickSize:n.orderPriceMinTickSize||"0.01",negRisk:!0===n.negRisk}}catch(t){if(404===t.status)return null;return o.k.error(`Error fetching market ${e}: ${t.message||t}`),null}}async function c(){let e=function(){let e=Math.floor(Date.now()/1e3);return`btc-updown-15m-${900*Math.floor(e/900)}`}(),t=await d(e);if(t&&t.active)return t;let n=Math.floor(Date.now()/1e3),r=`btc-updown-15m-${(Math.floor(n/900)-1)*900}`;return(t=await d(r))&&t.active?t:null}async function u(e){try{let t=(0,s.YX)(),[n,r]=await Promise.all([t.getOrderBook(e.yesTokenId).catch(()=>null),t.getOrderBook(e.noTokenId).catch(()=>null)]),i=.5,a=.5;n&&(n.asks&&n.asks.length>0?i=parseFloat(n.asks[0].price):n.last_trade_price&&(i=parseFloat(n.last_trade_price))),r&&(r.asks&&r.asks.length>0?a=parseFloat(r.asks[0].price):r.last_trade_price&&(a=parseFloat(r.last_trade_price))),i>0&&.5===a?a=Math.max(.01,1-i):a>0&&.5===i&&(i=Math.max(.01,1-a));let o=i>=a?"yes":"no",l="yes"===o?i:a;return{yesPrice:i,noPrice:a,leadingSide:o,leadingPrice:l,timestamp:Date.now()}}catch(e){return o.k.error(`Error fetching prices: ${e}`),null}}async function f(e){try{let t=await l("/markets",{slug:e});if(!t||!Array.isArray(t)||0===t.length)return o.k.debug(`[Resolution] No market found for slug: ${e}`),null;let n=t[0];if(!0===n.active&&!n.closed)return o.k.debug(`[Resolution] ${e} still active (active=${n.active}, closed=${n.closed})`),null;if(n.outcomePrices){let t;if("string"==typeof n.outcomePrices)try{let e=JSON.parse(n.outcomePrices);t=Array.isArray(e)?e.map(Number):n.outcomePrices.split(",").map(Number)}catch{t=n.outcomePrices.split(",").map(Number)}else{if(!Array.isArray(n.outcomePrices))return o.k.debug(`[Resolution] ${e} unexpected outcomePrices type: ${typeof n.outcomePrices}`),null;t=n.outcomePrices.map(Number)}if(t.length>=2&&!t.some(isNaN)){if(t[0]>t[1])return o.k.info(`[Resolution] ${e} resolved YES/UP (prices: ${t})`),"yes";if(t[1]>t[0])return o.k.info(`[Resolution] ${e} resolved NO/DOWN (prices: ${t})`),"no"}o.k.debug(`[Resolution] ${e} outcomePrices inconclusive: ${JSON.stringify(t)}`)}else o.k.debug(`[Resolution] ${e} closed but no outcomePrices (active=${n.active}, closed=${n.closed})`);return null}catch(t){return o.k.error(`[Resolution] Failed to fetch ${e}: ${t}`),null}}async function p(e){try{let t=(0,s.YX)(),n=await t.getMidpoints([{token_id:e.yesTokenId,side:a.MF.BUY},{token_id:e.noTokenId,side:a.MF.BUY}]),r=parseFloat(n?.[e.yesTokenId]||"0"),i=parseFloat(n?.[e.noTokenId]||"0");if(o.k.debug(`[Resolution CLOB] ${e.slug} YES=${r} NO=${i}`),r>.9)return"yes";if(i>.9)return"no";return null}catch(t){return o.k.debug(`[Resolution CLOB] Failed for ${e.slug}: ${t}`),null}}async function g(e){try{let t=(0,s.YX)(),n=await t.getMidpoints([{token_id:e.yesTokenId,side:a.MF.BUY},{token_id:e.noTokenId,side:a.MF.BUY}]),r=parseFloat(n?.[e.yesTokenId]||"0.5"),i=parseFloat(n?.[e.noTokenId]||"0.5"),o=r>=i?"yes":"no";return{yesPrice:r,noPrice:i,leadingSide:o,leadingPrice:"yes"===o?r:i,timestamp:Date.now()}}catch{return u(e)}}var $=n(3412);function m(e,t){let n=t*(1-t);return .25*e*n*n}async function h(e,t,n,r,i,a,l={}){let d=r/n,c="yes"===t?e.yesTokenId:e.noTokenId,u=m(d,n),f=l.expectedPrice?Math.abs(n-l.expectedPrice)/l.expectedPrice:0;if(i)return o.k.info(`[PAPER] BUY ${d.toFixed(4)} ${t} @ $${n.toFixed(4)} ($${r}) | Asset: ${l.asset||"?"} | Strategy: ${l.subStrategy||"?"} | Fee: $${u.toFixed(6)}`),{trade:(0,$.Ei)({timestamp:new Date().toISOString(),conditionId:e.conditionId,slug:e.slug,side:t,action:"buy",price:n,amount:r,shares:d,pnl:null,paper:!0,orderId:null,asset:l.asset||null,subStrategy:l.subStrategy||null,binancePriceAtEntry:null,slippage:f,takerFee:u})};o.k.info(`[LIVE] Placing BUY: ${d.toFixed(4)} ${t} @ $${n.toFixed(4)}`);let p=await (0,s.L4)(c,n,d,e.tickSize,e.negRisk);return p.success?{trade:(0,$.Ei)({timestamp:new Date().toISOString(),conditionId:e.conditionId,slug:e.slug,side:t,action:"buy",price:n,amount:r,shares:d,pnl:null,paper:!1,orderId:p.orderId||null,asset:l.asset||null,subStrategy:l.subStrategy||null,binancePriceAtEntry:null,slippage:f,takerFee:u})}:(o.k.error(`Buy order failed: ${p.error}`),{trade:null,error:p.error})}async function y(e,t,n,r,i={}){let a="yes"===t.side?e.yesTokenId:e.noTokenId,l=t.shares*n,d=l-t.costBasis,c=m(t.shares,n);if(r)return o.k.info(`[PAPER] SELL ${t.shares.toFixed(4)} ${t.side} @ $${n.toFixed(4)} | P&L: $${d.toFixed(4)}`),{trade:(0,$.Ei)({timestamp:new Date().toISOString(),conditionId:e.conditionId,slug:e.slug,side:t.side,action:"sell",price:n,amount:l,shares:t.shares,pnl:d,paper:!0,orderId:null,asset:i.asset||null,subStrategy:i.subStrategy||null,binancePriceAtEntry:null,slippage:null,takerFee:c})};o.k.info(`[LIVE] Placing SELL: ${t.shares.toFixed(4)} ${t.side} @ $${n.toFixed(4)}`);let u=await (0,s.EG)(a,n,t.shares,e.tickSize,e.negRisk);return u.success?{trade:(0,$.Ei)({timestamp:new Date().toISOString(),conditionId:e.conditionId,slug:e.slug,side:t.side,action:"sell",price:n,amount:l,shares:t.shares,pnl:d,paper:!1,orderId:u.orderId||null,asset:i.asset||null,subStrategy:i.subStrategy||null,binancePriceAtEntry:null,slippage:null,takerFee:c})}:(o.k.error(`Sell order failed: ${u.error}`),{trade:null,error:u.error})}let S=null,P={windowsPlayed:0,bothSidesFilled:0,oneSideFilled:0,neitherFilled:0,totalPnl:0,avgProfitPerWindow:0},k=null,w=0,I=30,b=()=>{},x=()=>{},M=()=>{};async function F(e,t,n){if(!e.arbEnabled)return;let r=t.find(t=>t.asset===e.arbMarket);if(!r)return;let i=Math.floor(Date.now()/1e3),a=900*Math.floor(i/900),s=`${e.arbMarket.toLowerCase()}-arb-${a}`,o=a+900-i;if(S&&S.windowId!==s&&(await D(S,n),S=null,k=null),S&&o<=e.arbCancelBeforeEnd&&"active"===S.status&&(await C(S,n),S.status="cancelling",x(`[ARB] Cancelled unfilled orders -- ${o}s before resolution`)),!(o<=e.arbCancelBeforeEnd)){if(k===s){n&&S&&"active"===S.status&&function(e,t){let n=t.yesPrice,r=t.noPrice,i=!1;for(let t of e.upSide.orders)if(("placed"===t.status||"partial"===t.status)&&n<=t.price+.02){let e=n<=t.price?1:.3,r=t.targetSize*e;r>t.filledSize&&(t.filledSize=r,t.status=t.filledSize>=t.targetSize?"filled":"partial",i=!0)}for(let t of e.downSide.orders)if(("placed"===t.status||"partial"===t.status)&&r<=t.price+.02){let e=r<=t.price?1:.3,n=t.targetSize*e;n>t.filledSize&&(t.filledSize=n,t.status=t.filledSize>=t.targetSize?"filled":"partial",i=!0)}i&&(B(e.upSide),B(e.downSide),E())}(S,r);return}if(I<e.arbMaxPerWindow)return;await v(e,r,s,a,n)}}async function v(e,t,n,r,i){let a=null!=e.arbBudgetUp&&e.arbBudgetUp>0?e.arbBudgetUp:e.arbMaxPerWindow/2,l=null!=e.arbBudgetDown&&e.arbBudgetDown>0?e.arbBudgetDown:e.arbMaxPerWindow/2,d=[],c=[];for(let u of e.arbLadderLevels){let e=a*u.allocation,f=l*u.allocation,p=e/u.price,g=f/u.price,$={side:"yes",price:u.price,targetSize:p,filledSize:0,orderId:null,status:"pending"},m={side:"no",price:u.price,targetSize:g,filledSize:0,orderId:null,status:"pending"};if(i)$.orderId=`paper-up-${u.price}-${r}`,$.status="placed",m.orderId=`paper-down-${u.price}-${r}`,m.status="placed";else{let e=await (0,s.pQ)(t.yesTokenId,u.price,p,t.tickSize,t.negRisk);e.success&&e.orderId&&($.orderId=e.orderId,$.status="placed");let n=await (0,s.pQ)(t.noTokenId,u.price,g,t.tickSize,t.negRisk);n.success&&n.orderId&&(m.orderId=n.orderId,m.status="placed")}d.push($),c.push(m),o.k.info(`[ARB] Limit order: UP $${u.price} x ${p.toFixed(2)} shares | DOWN $${u.price} x ${g.toFixed(2)} shares | window=${n}`)}I-=e.arbMaxPerWindow,w=e.arbMaxPerWindow,S={windowId:n,conditionId:t.conditionId,slug:t.slug,asset:e.arbMarket,startTime:r,endTime:r+900,secondsRemaining:r+900-Math.floor(Date.now()/1e3),upSide:{totalShares:0,totalCost:0,avgPrice:0,orders:d},downSide:{totalShares:0,totalCost:0,avgPrice:0,orders:c},combinedCost:0,guaranteedPnl:0,status:"active",resolution:"pending",pnl:null},k=n,P.windowsPlayed++,x(`[ARB] Placed ${2*e.arbLadderLevels.length} limit orders for ${n}`),M("info",`Arb: Placed ladder orders for ${e.arbMarket}`,e.arbMarket)}function B(e){let t=0,n=0;for(let r of e.orders)t+=r.filledSize,n+=r.filledSize*r.price;e.totalShares=t,e.totalCost=n,e.avgPrice=t>0?n/t:0}function E(){if(!S)return;let e=S.upSide,t=S.downSide;if(e.avgPrice>0&&t.avgPrice>0){S.combinedCost=e.avgPrice+t.avgPrice;let n=Math.min(e.totalShares,t.totalShares);S.guaranteedPnl=n*(1-S.combinedCost)}else e.avgPrice>0||t.avgPrice>0?S.combinedCost=e.avgPrice+t.avgPrice:S.combinedCost=0,S.guaranteedPnl=0}async function C(e,t){let n=[];for(let r of[...e.upSide.orders,...e.downSide.orders])("placed"===r.status||"partial"===r.status)&&r.orderId&&(t||n.push(r.orderId),r.status="cancelled");n.length>0&&!t&&await (0,s._e)(n),B(e.upSide),B(e.downSide),E(),o.k.info(`[ARB] Cancelled ${n.length} unfilled orders | UP: ${e.upSide.totalShares.toFixed(2)} shares | DOWN: ${e.downSide.totalShares.toFixed(2)} shares | Combined: $${e.combinedCost.toFixed(3)}`)}async function D(e,t){"active"===e.status&&await C(e,t),e.status="resolved";let n=e.upSide.totalShares,r=e.downSide.totalShares,i=e.upSide.totalCost,a=e.downSide.totalCost,s=i+a,l=n>0&&r>0,d=n>0!=r>0;if(l?P.bothSidesFilled++:d?P.oneSideFilled++:P.neitherFilled++,0===s){I=Math.min(30,I+w),x(`[ARB] Window ${e.windowId} -- no fills, capital returned`);return}if(n>0){let r=(0,$.Ei)({timestamp:new Date().toISOString(),conditionId:e.conditionId,slug:e.slug,side:"yes",action:"buy",price:e.upSide.avgPrice,amount:i,shares:n,pnl:null,paper:t,orderId:null,asset:e.asset,subStrategy:"arbitrage",binancePriceAtEntry:null,slippage:null,takerFee:0});b(r)}if(r>0){let n=(0,$.Ei)({timestamp:new Date().toISOString(),conditionId:e.conditionId,slug:e.slug,side:"no",action:"buy",price:e.downSide.avgPrice,amount:a,shares:r,pnl:null,paper:t,orderId:null,asset:e.asset,subStrategy:"arbitrage",binancePriceAtEntry:null,slippage:null,takerFee:0});b(n)}if(t&&s>0){let t=Math.random()>.5,o=t?1*n:0,l=t?0:1*r,d=o+l,c=d-s;if(e.resolution=t?"up":"down",e.pnl=c,n>0){let r=(0,$.Ei)({timestamp:new Date().toISOString(),conditionId:e.conditionId,slug:e.slug,side:"yes",action:"resolution",price:t?1:0,amount:o,shares:n,pnl:o-i,paper:!0,orderId:null,asset:e.asset,subStrategy:"arbitrage",binancePriceAtEntry:null,slippage:null,takerFee:null});b(r)}if(r>0){let n=(0,$.Ei)({timestamp:new Date().toISOString(),conditionId:e.conditionId,slug:e.slug,side:"no",action:"resolution",price:t?0:1,amount:l,shares:r,pnl:l-a,paper:!0,orderId:null,asset:e.asset,subStrategy:"arbitrage",binancePriceAtEntry:null,slippage:null,takerFee:null});b(n)}P.totalPnl+=c,P.bothSidesFilled+P.oneSideFilled>0&&(P.avgProfitPerWindow=P.totalPnl/(P.bothSidesFilled+P.oneSideFilled)),I=Math.min(30,I+d),x(`[ARB] ${c>=0?"WIN":"LOSS"} Window resolved ${t?"UP":"DOWN"} | Invested: $${s.toFixed(2)} | Payout: $${d.toFixed(2)} | P&L: $${c.toFixed(2)}`),M(c>=0?"success":"warning",`Arb ${t?"UP":"DOWN"}: P&L $${c.toFixed(2)} (invested $${s.toFixed(2)})`,e.asset)}else I=Math.min(30,I+s);o.k.info(`[ARB] Window summary: ${e.windowId} | UP: ${n.toFixed(2)} @ $${e.upSide.avgPrice.toFixed(3)} | DOWN: ${r.toFixed(2)} @ $${e.downSide.avgPrice.toFixed(3)} | Combined: $${e.combinedCost.toFixed(3)} | P&L: ${null!==e.pnl?"$"+e.pnl.toFixed(2):"pending"}`)}var T=n(24979);let O="stopped",A="disconnected",L="Idle",R=null,z=null,N=null,U=null,W=new Map,_=new Map,Y=new Map,J=!1,j=null,V=null,X=[],q=0,G=null,H=null,Q=null,K=null,Z=0;function ee(){let e=Date.now();return(!K||e-Z>5e3)&&(K=(0,$.Gw)(),Z=e),K}function et(){K=null,Z=0}let en=!1,er={},ei=new Set,ea=!1;function es(){if(ea)return;ea=!0;let e=ee();(0,T.up)(e.enabledAssets),o.k.info("[Engine] Auto-started market scanner for dashboard")}let eo="";function el(e){return es(),function(){if(Q)return;let e=0;Q=setInterval(()=>{if(0===ei.size)return;let t=ee(),n={};for(let e of(0,T.$2)())n[e.asset]=e;0===Object.keys(n).length?(5==++e||e%30==0)&&(o.k.warn(`[Engine] No active markets found after ${e} broadcast cycles - Polymarket API may be unreachable from this server`),ef("No market data - Polymarket API may be unreachable from this server. Check logs for details.")):e=0;let r=(0,T.bp)(t.enabledAssets),i=JSON.stringify(r),a=i!==eo;a&&(eo=i),ed({type:"price",data:{markets:n,...a?{recentOutcomes:r}:{}},timestamp:new Date().toISOString()})},2e3)}(),ei.add(e),e({type:"state",data:e$(),timestamp:new Date().toISOString()}),()=>ei.delete(e)}function ed(e){for(let t of ei)try{t(e)}catch{ei.delete(t)}}function ec(){ed({type:"state",data:e$(),timestamp:new Date().toISOString()})}function eu(e){ed({type:"trade",data:e,timestamp:new Date().toISOString()})}function ef(e){ed({type:"log",data:{message:e},timestamp:new Date().toISOString()})}function ep(e,t,n){let r={id:`alert-${++q}`,timestamp:new Date().toISOString(),severity:e,message:t,asset:n};X.unshift(r),X.length>100&&(X.length=100),ed({type:"alert",data:r,timestamp:r.timestamp})}function eg(e){let t=0;for(let e of W.values())t+=e.costBasis;t+=S?S.upSide.totalCost+S.downSide.totalCost:0;let n=(0,$._l)(),r=(0,$.uF)(),i=(0,$.vs)();return{totalBankroll:e.totalBankroll,deployed:t,available:Math.max(0,e.maxTotalExposure-t),maxExposure:e.maxTotalExposure,todayPnl:n,winStreak:i,totalLosses:r}}function e$(){let e;let t=ee(),n=function(){let e=Math.floor(Date.now()/1e3);return(Math.floor(e/900)+1)*900-e}(),r=!1;z?N?n>t.highConfTimeMax?e=`${(n/60).toFixed(1)}m remaining (need <= ${Math.floor(t.highConfTimeMax/60)}m)`:N.leadingPrice<t.highConfEntryMin||N.leadingPrice>t.highConfEntryMax?e=`Price $${N.leadingPrice.toFixed(4)} outside range $${t.highConfEntryMin}-$${t.highConfEntryMax}`:r=!0:e="Waiting for price data":e="No active market found";let i={market:z,prices:N,secondsRemaining:n,eligible:r,ineligibleReason:e},a={};for(let e of(0,T.$2)())a[e.asset]=e;let s={};for(let[e,t]of W)s[e]=t;return{status:O,connection:A,lastAction:L,lastActionTime:R,currentMarket:i,currentPosition:U,settings:t,cumulativePnl:(0,$.NW)(),totalTrades:(0,$.yW)(),activeMarkets:a,positions:s,capital:eg(t),circuitBreaker:{triggered:J,reason:j,resumeAt:V,dailyPnl:(0,$._l)(),totalLosses:(0,$.uF)()},clobReady:en,alerts:X.slice(0,50),arbState:function(){if(!S)return null;let e=Math.floor(Date.now()/1e3);return S.secondsRemaining=Math.max(0,S.endTime-e),E(),{...S}}(),arbStats:{...P}}}async function em(){try{A="connecting";let e=await c();if(e){z&&z.conditionId!==e.conditionId&&o.k.info(`Market rotated: ${z.slug} -> ${e.slug}`),z=e,_.set(e.conditionId,e),A="connected";let t=await g(e);t&&(N=t,U&&(U.currentPrice="yes"===U.side?t.yesPrice:t.noPrice,U.unrealizedPnl=U.shares*U.currentPrice-U.costBasis))}else z=null,N=null,A="connected"}catch(t){A="disconnected";let e=[t?.message?`message=${t.message}`:null,t?.code?`code=${t.code}`:null,t?.name?`name=${t.name}`:null,t?.response?.status?`status=${t.response.status}`:null,t?.config?.url?`url=${t.config.url}`:null].filter(Boolean).join(" ");o.k.error(`Market refresh failed${e?` (${e})`:""}`),ef(`Connection error${e?`: ${e}`:""}`)}ec()}async function eh(){if("running"===O){try{let e=ee();if(function(e){if(J){if(V){let e=new Date(V).getTime();if(Date.now()>=e)return J=!1,j=null,V=null,ep("info","Circuit breaker cooldown ended. Bot resumed."),!1}return!0}let t=(0,$._l)();if(t<-e.dailyLossLimit)return J=!0,j=`Daily loss $${Math.abs(t).toFixed(2)} exceeded limit $${e.dailyLossLimit}`,V=new Date(Date.now()+144e5).toISOString(),ep("error",`Circuit breaker triggered: ${j}. Pausing for 4 hours.`),!0;let n=(0,$.uF)();return n>=e.lossLimit&&(J=!0,j=`${n} losses today (limit: ${e.lossLimit})`,ep("error",`Circuit breaker triggered: ${j}. Bot stopped.`),!0)}(e)){ec();return}let t=(0,T.$2)();if(0===t.length){let e=Date.now(),t=er._noMarkets;(!t||e-t.time>=15e3)&&(er._noMarkets={reason:"no markets",time:e},ef("Scanning for active 15-minute markets..."))}for(let n of t){if(!e.enabledAssets.includes(n.asset))continue;let t=`${n.asset}-${n.conditionId}`,r=W.get(t)||null;if(!r&&W.size>=e.maxSimultaneousPositions)continue;let i=function(e,t,n,r){let i=t.secondsRemaining,a=t.yesPrice,s=t.noPrice;if(!e.highConfEnabled)return{action:"wait",reason:"High-confidence strategy disabled"};let o=a>=s?"yes":"no",l="yes"===o?a:s;if(r&&r.shares>0){if(i>=e.highConfTimeMin&&i<=e.highConfTimeMax&&l>=e.highConfEntryMin&&l<=e.highConfEntryMax&&o===r.side){let n=Date.now(),i=1e3*e.highConfBuyInterval;if(!r.lastBuyTime||n-r.lastBuyTime>=i)return{action:"buy",reason:`DCA: ${t.asset} ${r.side.toUpperCase()} @ $${l.toFixed(4)} � every ${e.highConfBuyInterval}s � $${r.costBasis.toFixed(2)} deployed`,side:r.side,price:l}}return{action:"hold",reason:`Holding ${r.side.toUpperCase()} @ $${r.avgEntryPrice.toFixed(4)} � ${r.shares.toFixed(2)} shares � $${r.costBasis.toFixed(2)}`}}return i<e.highConfTimeMin?{action:"wait",reason:`Window closing in ${i}s � no new entries`}:i>e.highConfTimeMax?{action:"wait",reason:`${t.asset}: ${Math.floor(i/60)}m left � waiting for ?${Math.floor(e.highConfTimeMax/60)}m`}:l>=e.highConfEntryMin&&l<=e.highConfEntryMax?{action:"buy",reason:`Entry: ${t.asset} ${o.toUpperCase()} @ $${l.toFixed(4)} (${Math.floor(i/60)}m left)`,side:o,price:l}:{action:"wait",reason:`${t.asset}: $${l.toFixed(4)} outside range $${e.highConfEntryMin}�$${e.highConfEntryMax}`}}(e,n,0,r);switch(i.action){case"buy":{if(!i.side||!i.price)break;let a=r?r.side:i.side,s="yes"===a?n.yesPrice:n.noPrice,o=e.highConfBuyAmount,l=Math.max(0,e.maxTotalExposure-eg(e).deployed);if((o=Math.min(o,e.perWindowMax-(r?.costBasis??0),l))<=0||r&&r.costBasis>=e.perWindowMax)break;let{trade:d,error:c}=await h(n.market,a,s,o,e.paperTrading,r?{conditionId:r.marketId,side:r.side,shares:r.shares,avgEntryPrice:r.avgEntryPrice,costBasis:r.costBasis,currentPrice:r.currentPrice,unrealizedPnl:r.unrealizedPnl}:null,{asset:n.asset,subStrategy:"highConfidence",expectedPrice:s});d?(r?(r.shares+=d.shares,r.costBasis+=d.amount,r.avgEntryPrice=r.costBasis/r.shares,r.lastBuyTime=Date.now()):(W.set(t,{marketId:n.conditionId,slug:n.slug,asset:n.asset,side:a,shares:d.shares,avgEntryPrice:s,currentPrice:s,unrealizedPnl:0,entryTime:new Date().toISOString(),hedged:!1,costBasis:d.amount,subStrategy:"highConfidence",lastBuyTime:Date.now()}),_.set(n.conditionId,n.market),"BTC"===n.asset&&(U={conditionId:n.conditionId,side:a,shares:d.shares,avgEntryPrice:s,costBasis:d.amount,currentPrice:s,unrealizedPnl:0})),L=`Buy ${n.asset} ${a} @ $${s.toFixed(4)}`,R=new Date().toISOString(),eu(d),ep("info",`Buy: ${n.asset} ${a.toUpperCase()} @ $${s.toFixed(4)}`,n.asset)):c&&ef(`Buy failed (${n.asset}): ${c}`),ef(i.reason);break}case"sell":{if(!r||!i.price||!i.side)break;let{trade:a,error:s}=await y(n.market,{conditionId:r.marketId,side:r.side,shares:r.shares,avgEntryPrice:r.avgEntryPrice,costBasis:r.costBasis,currentPrice:r.currentPrice,unrealizedPnl:r.unrealizedPnl},i.price,e.paperTrading,{asset:n.asset});a?(L=`Sold ${n.asset} ${r.side} @ $${i.price.toFixed(4)}`,R=new Date().toISOString(),W.delete(t),"BTC"===n.asset&&(U=null),eu(a),ep("warning",`Sold: ${n.asset} @ $${i.price.toFixed(4)} | P&L: $${a.pnl?.toFixed(4)}`,n.asset)):s&&ef(`Sell failed (${n.asset}): ${s}`),ef(i.reason);break}case"hold":case"wait":{let e=Date.now(),t=er[n.asset],r=!t||t.reason!==i.reason,a=!t||e-t.time>=15e3;(r||a)&&(er[n.asset]={reason:i.reason,time:e},ef(i.reason))}}}try{await F(e,t,e.paperTrading)}catch(e){o.k.error(`[ARB] Tick error: ${e}`)}for(let[t,n]of Array.from(W.entries())){let r=(0,T.rs)(n.asset),i=parseInt(n.slug.split("-").pop()||"0",10),a=Math.max(0,i+900-Math.floor(Date.now()/1e3)),s=r&&r.conditionId!==n.marketId,l=a<=0;if(!s&&!l)continue;let d=Y.get(t)||0;if(Date.now()-d<5e3)continue;Y.set(t,Date.now());let c=_.get(n.marketId);if(!c){o.k.warn(`[Resolution] No cached MarketInfo for ${t}, cannot resolve`);continue}let u=await f(n.slug);if(null===u&&(u=await p(c)),null===u){o.k.debug(`[Resolution] ${t} not resolved yet, will retry`);continue}let g={conditionId:n.marketId,side:n.side,shares:n.shares,avgEntryPrice:n.avgEntryPrice,costBasis:n.costBasis,currentPrice:n.currentPrice,unrealizedPnl:n.unrealizedPnl},m=function(e,t,n,r,i={}){let a=t.side===n,s=a?t.shares:0,l=s-t.costBasis;return o.k.info(`[${r?"PAPER":"LIVE"}] RESOLUTION: ${a?"WON":"LOST"} | ${t.shares.toFixed(4)} shares | Payout: $${s.toFixed(4)} | P&L: $${l.toFixed(4)}`),(0,$.Ei)({timestamp:new Date().toISOString(),conditionId:e.conditionId,slug:e.slug,side:t.side,action:"resolution",price:"yes"===n?1:0,amount:s,shares:t.shares,pnl:l,paper:r,orderId:null,asset:i.asset||null,subStrategy:i.subStrategy||null,binancePriceAtEntry:null,slippage:null,takerFee:null})}(c,g,u,e.paperTrading,{asset:n.asset}),h=n.side===u;(0,T.E3)(n.slug,"yes"===u?"up":"down"),W.delete(t),Y.delete(t),"BTC"===n.asset&&(U=null),eu(m),ef(`${n.asset} resolved ${"yes"===u?"UP":"DOWN"} - ${h?"WON":"LOST"} | P&L: $${m.pnl?.toFixed(4)}`),ep(h?"success":"warning",`${n.asset} resolved ${"yes"===u?"UP":"DOWN"}: ${h?"WON":"LOST"} ($${m.pnl?.toFixed(4)})`,n.asset)}for(let[,e]of W){let t=(0,T.rs)(e.asset);t&&(e.currentPrice="yes"===e.side?t.yesPrice:t.noPrice,e.unrealizedPnl=e.shares*e.currentPrice-e.costBasis)}}catch(e){o.k.error(`Trading loop error: ${e}`),ef(`Error: ${e}`)}ec()}}function ey(){var e,t,n;if("running"===O)return{success:!1,error:"Bot is already running"};o.k.info("Starting bot..."),O="running",L="Bot started",R=new Date().toISOString(),e=e=>eu(e),t=e=>ef(e),n=(e,t,n)=>ep(e,t,n),b=e,x=t,M=n;let r=ee();return es(),ep("info",`Market scanner active for: ${r.enabledAssets.join(", ")}`),r.paperTrading?(en=!1,ep("info","Paper mode - CLOB client not needed")):(0,s.tS)().then(e=>{(en=!!e)?ep("success","CLOB client connected - live trading ready"):ep("error","CLOB client failed - check PRIVATE_KEY and FUNDER_ADDRESS in .env.local"),ec()}).catch(()=>{en=!1,ep("error","CLOB client initialization failed"),ec()}),em(),G=setInterval(eh,3e3),H=setInterval(em,3e4),ec(),ef("Bot started"),ep("success","Bot started successfully"),{success:!0}}function eS(){return"stopped"===O?{success:!1,error:"Bot is already stopped"}:(o.k.info("Stopping bot..."),G&&(clearInterval(G),G=null),H&&(clearInterval(H),H=null),O="stopped",en=!1,et(),L="Bot stopped",R=new Date().toISOString(),ec(),ef("Bot stopped"),ep("info","Bot stopped"),{success:!0})}function eP(){return J=!1,j=null,V=null,ep("info","Circuit breaker manually reset"),ec(),{success:!0}}}};